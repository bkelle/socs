import argparse
import time

# specific module for actuator controller
import gclib

from ocs import ocs_agent
from ocs import site_config
from ocs.ocs_twisted import TimeoutLock

# import classes / configs
from src.Actuator import Actuator
import limitswitch_config
import stopper_config


class WiregridActuatorAgent:

    def __init__(self, agent, ip_address='192.168.1.100',
                 interval_time=1, sleep=0.10, verbose=0):
        self.agent = agent
        self.log = agent.log
        self.lock = TimeoutLock()
        self.run_acq = False
        self.ip_address = ip_address
        self.interval_time = interval_time
        self.sleep = sleep
        self.max_check_stopper = 100
        self.verbose = verbose

        agg_params = {'frame_length': 60}
        self.agent.register_feed(
                'WGActuator', record=True, agg_params=agg_params)

        try:
            self.actuator = Actuator(
                self.ip_address, sleep=self.sleep, verbose=self.verbose,
                ls_io=limitswitch_config.IO_INFO,
                st_io=stopper_config.IO_INFO)
        except Exception as e:
            msg = 'Failed to initialize Actuator instance! \
                | Exception: {}'.format(e)
            self.log.warn(msg)
            self.actuator = None

    ######################
    # Internal functions #
    ######################

    def _check_connect(self):
        if self.actuator is None:
            msg = 'WARNING: \
                No connection to the actuator (actuator instance is None).'
            self.log.warn(msg)
            return False, msg
        else:
            try:
                self.actuator.check_connect()
            except Exception as e:
                msg = 'WARNING: Failed to check connection with the actuator! \
                    | Exception: {}'.format(e)
                self.log.warn(msg)
                return False, msg
        return True, 'Connection is OK.'

    def _reconnect(self):
        self.log.warn('*** Trying to reconnect... ***')
        # reconnect
        try:
            if self.actuator:
                del self.actuator
            self.actuator = Actuator(
                    self.ip_address, sleep=self.sleep, verbose=self.verbose,
                    ls_io=limitswitch_config.IO_INFO,
                    st_io=stopper_config.IO_INFO)
        except Exception as e:
            msg = 'WARNING: \
                Failed to initialize Actuator! | Exception: {}'.format(e)
            self.log.warn(msg)
            self.actuator = None
            return False, msg
        # check the connection
        ret, msg = self._check_connect()
        if ret:
            msg = 'Successfully reconnected to the actuator!'
            self.log.info(msg)
            return True, msg
        else:
            msg = 'WARNING: Failed to reconnect to the actuator!'
            self.log.warn(msg)
            if self.actuator:
                del self.actuator
            self.actuator = None
            return False, msg

    # Power off stopper
    def _stopper_off(self):
        try:
            self.actuator.stopper.set_alloff()
        except Exception as e:
            msg = 'ERROR: Failed to set OFF all the stoppers in set_alloff()! \
                    | Exception: {}'.format(e)
            self.log.error(msg)
            return False, msg
        return True, 'Successfully set OFF all the stoppers!'

    # Return value: True/False, message, limit-switch ON/OFF
    def _forward(self, distance, speedrate=0.1):
        distance = abs(distance)
        LSL2 = 0  # left  actuator outside limit-switch
        LSR2 = 0  # right actuator outside limit-switch
        LSL2, LSR2 = \
            self.actuator.limitswitch.get_onoff(io_name=['LSL2', 'LSR2'])
        if LSL2 == 0 and LSR2 == 0:
            ret, msg = self.actuator.move(distance, speedrate)
            if not ret:
                return False, msg, LSL2 or LSR2
        else:
            self.log.warn(
                'One of inside limit-switches is ON (LSL2={}, LSR2={})!'
                .format(LSL2, LSR2))
            self.log.warn('  --> Did not move.')
        isrun = True
        # Loop until the limit-switch is ON or the actuator moving finishes
        while LSL2 == 0 and LSR2 == 0 and isrun:
            LSL2, LSR2 = \
                self.actuator.limitswitch.get_onoff(io_name=['LSL2', 'LSR2'])
            isrun, msg = self.actuator.isRun()
            if self.verbose > 0:
                self.log.info(
                    'LSL2={}, LSR2={}, run={}'.format(LSL2, LSR2, isrun))
        # Stop the actuator moving
        self.actuator.hold()
        LSonoff = LSL2 or LSR2
        if LSonoff:
            self.log.info(
                'Stopped moving because \
                one of inside limit-switches is ON (LSL2={}, LSR2={})!'
                .format(LSL2, LSR2))
        self.actuator.release()
        return True, \
            'Finish forward(distance={}, speedrate={}, limit-switch={})'\
            .format(distance, speedrate, LSonoff), \
            LSonoff

    # Return value: True/False, message, limit-switch ON/OFF
    def _backward(self, distance, speedrate=0.1):
        distance = abs(distance)
        LSL1 = 0  # left  actuator limit-switch @ motor (outside)
        LSR1 = 0  # right actuator limit-switch @ motor (outside)
        LSL1, LSR1 = \
            self.actuator.limitswitch.get_onoff(io_name=['LSL1', 'LSR1'])
        if LSL1 == 0 and LSR1 == 0:
            ret, msg = self.actuator.move(-1*distance, speedrate)
            if not ret:
                return False, msg, LSL1 or LSR1
        else:
            self.log.warn(
                'One of outside limit-switches is ON (LSL1={}, LSR1={})!'
                .format(LSL1, LSR1))
            self.log.warn('  --> Did not move.')
        isrun = True
        # Loop until the limit-switch is ON or the actuator moving finishes
        while LSL1 == 0 and LSR1 == 0 and isrun:
            LSL1, LSR1 = \
                 self.actuator.limitswitch.get_onoff(io_name=['LSL1', 'LSR1'])
            isrun, msg = self.actuator.isRun()
            if self.verbose > 0:
                self.log.info(
                    'LSL1={}, LSR1={}, run={}'.format(LSL1, LSR1, isrun))
        # Stop the actuator moving
        self.actuator.hold()
        LSonoff = LSL1 or LSR1
        if LSonoff:
            self.log.info(
                'Stopped moving because \
                one of outside limit-switches is ON (LSL1={}, LSR1={})!'
                .format(LSL1, LSR1))
        self.actuator.release()
        return True, \
            'Finish backward(distance={}, speedrate={}, limit-switch={})'\
            .format(distance, speedrate, LSonoff), \
            LSonoff

    def _insert(self, main_distance=850, main_speedrate=1.0):
        # Check motor limit-switch
        LSL1, LSR1 = \
            self.actuator.limitswitch.get_onoff(io_name=['LSL1', 'LSR1'])
        # If limit-switch is not ON (The actuator is not at the end.)
        if LSL1 == 0 and LSR1 == 0:
            self.log.warn(
                'The outside limit-switch is NOT ON before inserting.')
            if main_speedrate > 0.1:
                self.log.warn(
                    ' --> Change speedrate: {} --> 0.1'
                    .format(main_speedrate))
                main_speedrate = 0.1
        else:
            self.log.info(
                'The outside limit-switch is ON before inserting.')

        # Check connection
        ret, msg = self._check_connect()
        self.log.info(msg)
        # Reconnect if connection check is failed
        if not ret:
            self.log.warn('Trying to reconnect to the actuator...')
            ret2, msg2 = self._reconnect()
            self.log.warn(msg2)
            if not ret2:
                msg = 'WARNING: Could not connect to \
                    the actuator even after reconnection! --> Stop inserting!'
                self.log.warn(msg)
                return False, msg

        # Release stopper twice (Powering ON the stoppers)
        # 1st trial
        try:
            self.actuator.stopper.set_allon()
        except Exception as e:
            msg = 'ERROR: Failed to run the stopper set_allon() --> Stop inserting! \
                | Exception: {}'.format(e)
            self.log.error(msg)
            return False, msg
        # 2nd trial (double check)
        try:
            self.actuator.stopper.set_allon()
        except Exception as e:
            msg = 'ERROR: Failed to run the stopper set_allon() --> Stop inserting! \
                | Exception: {}'.format(e)
            self.log.error(msg)
            return False, msg

        # Initial slow & small forwarding
        ret, msg, LSonoff = self._forward(20, speedrate=0.1)
        # Check the status of the initial forwarding
        if not ret:
            msg = 'ERROR: (In the initail forwarding) {} \
                --> Stop inserting!'.format(msg)
            self.log.error(msg)
            # Lock the actuator by the stoppers
            self._stopper_off()
            return False, msg
        if LSonoff:
            msg = 'WARNING: Limit-switch is ON after the initial forwarding.\
                ---> Stop inserting!'
            self.log.warn(msg)
            # Lock the actuator by the stoppers
            ret, msg2 = self._stopper_off()
            if not ret:
                msg = \
                    'ERROR: (In the initial backwarding) \
                    Failed to lock the actuator by the stopper: {}'\
                    .format(msg2)
                return False, msg
            return True, msg
        # Check limit-switch
        LSL1, LSR1 = \
            self.actuator.limitswitch.get_onoff(io_name=['LSL1', 'LSR1'])
        if LSL1 == 1 or LSR1 == 1:
            msg = 'ERROR!: The outside limit-switch is NOT OFF \
                after the initial forwarding. \
                (Maybe the limit-switch is disconnected?) --> Stop inserting!'
            self.log.error(msg)
            # Lock the actuator by the stoppers
            self._stopper_off()
            return False, msg

        # Sleep before the main forwarding
        time.sleep(1)

        # Main forward
        status, msg, LSonoff = \
            self._forward(main_distance, speedrate=main_speedrate)
        if not status:
            msg = 'ERROR!: (In the main forwarding) {} \
                    --> Stop inserting!'.format(msg)
            self.log.error(msg)
            return False, msg
        if LSonoff:
            msg = 'WARNING: Limit-switch is ON after the main forwarding.\
                ---> Stop inserting!'
            self.log.warn(msg)
            # Lock the actuator by the stoppers
            ret, msg2 = self._stopper_off()
            if not ret:
                msg = \
                    'ERROR: (In the main forwarding) \
                    Failed to lock the actuator by the stopper: {}'\
                    .format(msg2)
                return False, msg
            return True, msg

        # Last slow & small forward
        status, msg, LSonoff = self._forward(200, speedrate=0.1)
        if not status:
            msg = 'ERROR!: (In the last forwarding) {}'.format(msg)
            self.log.error(msg)
            return False, msg
        if LSonoff == 0:
            msg = 'ERROR!: \
                The inside limit-switch is NOT ON after _insert().'
            self.log.error(msg)
            return False, msg

        # Lock the actuator by the stoppers
        ret, msg = self._stopper_off()
        if not ret:
            msg = 'ERROR!: Failed to lock the actuator by the stopper\
                after the last forwarding.!'
            self.log.error(msg)
            return False, msg
        # Check the stopper until all the stoppers are OFF (released)
        for i in range(self.max_check_stopper):
            onoff_st = self.actuator.stopper.get_onoff()
            if not any(onoff_st):
                break
        if any(onoff_st):
            msg = 'ERROR!: (After the last forwarding) \
                Failed to release all the stoppers'
            self.log.error(msg)
            return True, msg

        return True, 'Successfully inserting!'

    def _eject(self, main_distance=850, main_speedrate=1.0):
        # Check motor limit-switch
        LSL2, LSR2 = \
            self.actuator.limitswitch.get_onoff(io_name=['LSL2', 'LSR2'])
        if LSL2 == 0 and LSR2 == 0:
            self.log.warn(
                    'The inside limit-switch is NOT ON before ejecting.')
            if main_speedrate > 0.1:
                self.log.warn(
                    ' --> Change speedrate: {} --> 0.1'
                    .format(main_speedrate))
                main_speedrate = 0.1
        else:
            self.log.info(
                'The inside limit-switch is ON before ejecting.')

        # Check connection
        ret, msg = self._check_connect()
        self.log.info(msg)
        # Reconnect if connection check is failed
        if not ret:
            self.log.warn('Trying to reconnect to the actuator...')
            ret2, msg2 = self._reconnect()
            self.log.warn(msg2)
            if not ret2:
                msg = 'WARNING: Could not connect to \
                    the actuator even after reconnection! --> Stop inserting!'
                self.log.warn(msg)
                return False, msg

        # Release stopper twice (Powering ON the stoppers)
        # 1st trial
        try:
            self.actuator.stopper.set_allon()
        except Exception as e:
            msg = 'ERROR: Failed to run the stopper set_allon() --> Stop inserting! \
                | Exception: {}'.format(e)
            self.log.error(msg)
            return False, msg
        # 2nd trial (double check)
        try:
            self.actuator.stopper.set_allon()
        except Exception as e:
            msg = 'ERROR: Failed to run the stopper set_allon() --> Stop inserting! \
                | Exception: {}'.format(e)
            self.log.error(msg)
            return False, msg

        # Initial slow & small backwarding
        ret, msg, LSonoff = self._backward(20, speedrate=0.1)
        # Check the status of the initial backwarding
        if not ret:
            msg = 'ERROR: (In the initail backwarding) {} \
                --> Stop ejecting!'.format(msg)
            self.log.error(msg)
            # Lock the actuator by the stoppers
            self._stopper_off()
            return False, msg
        if LSonoff:
            msg = 'WARNING: Limit-switch is ON after the initial backwarding.\
                ---> Stop ejecting!'
            self.log.warn(msg)
            # Lock the actuator by the stoppers
            ret, msg2 = self._stopper_off()
            if not ret:
                msg = \
                    'ERROR: (In the initial backwarding) \
                    Failed to lock the actuator by the stopper: {}'\
                    .format(msg2)
                return False, msg
            return True, msg

        # Check limit-switch
        LSL2, LSR2 = \
            self.actuator.limitswitch.get_onoff(io_name=['LSL2', 'LSR2'])
        if LSL2 == 1 or LSR2 == 1:
            msg = 'ERROR!: The inside limit-switch is NOT OFF \
                after the initial backwarding. \
                (Maybe the limit-switch is disconnected?) --> Stop ejecting!'
            self.log.error(msg)
            # Lock the actuator by the stoppers
            self._stopper_off()
            return False, msg

        # Sleep before the main backwarding
        time.sleep(1)

        # Main backward
        status, msg, LSonoff = \
            self._backward(main_distance, speedrate=main_speedrate)
        if not status:
            msg = 'ERROR!: (In the main backwarding) {} \
                    --> Stop ejecting!'.format(msg)
            self.log.error(msg)
            return False, msg
        if LSonoff:
            msg = 'WARNING: Limit-switch is ON after the main backwarding.\
                ---> Stop ejectting!'
            self.log.warn(msg)
            # Lock the actuator by the stoppers
            ret, msg2 = self._stopper_off()
            if not ret:
                msg = \
                    'ERROR: (In the main backwarding) \
                    Failed to lock the actuator by the stopper: {}'\
                    .format(msg2)
                return False, msg
            return True, msg

        # Last slow & small backward
        status, msg, LSonoff = self._backward(200, speedrate=0.1)
        if not status:
            msg = 'ERROR!: (In the last backwarding) {}'.format(msg)
            self.log.error(msg)
            return False, msg
        if LSonoff == 0:
            msg = 'ERROR!: \
                The outside limit-switch is NOT ON after _eject().'
            self.log.error(msg)
            return False, msg

        # Lock the actuator by the stoppers
        ret, msg = self._stopper_off()
        if not ret:
            msg = 'ERROR!: Failed to lock the actuator by the stopper\
                after the last backwarding.!'
            self.log.error(msg)
            return False, msg
        # Check the stopper until all the stoppers are OFF (released)
        for i in range(self.max_check_stopper):
            onoff_st = self.actuator.stopper.get_onoff()
            if not any(onoff_st):
                break
        if any(onoff_st):
            msg = 'ERROR!: (After the last backwarding) \
                Failed to release all the stoppers'
            self.log.error(msg)
            return True, msg

        return True, 'Successfully ejecting!'

    ##################
    # Main functions #
    ##################

    def check_limitswitch(self, session, params=None):
        if params is None:
            params = {}
        io_name = params.get('io_name', None)
        onoffs = []
        msg = ''
        with self.lock.acquire_timeout(timeout=3, job='check_limitswitch') \
                as acquired:
            if not acquired:
                self.log.warn(
                    'Lock could not be acquired because it is held by {}.'
                    .format(self.lock.job))
                return False, 'Could not acquire lock in check_limitswitch().'

            onoffs = self.actuator.limitswitch.get_onoff(io_name)
            io_names = self.actuator.limitswitch.get_io_name(io_name)
            pinlabels = self.actuator.limitswitch.get_label(io_name)
            for i, io_name in enumerate(io_names):
                pinlabel = pinlabels[i]
                msg += '{:10s} ({:20s}) : {}\n'.format(io_name, pinlabel, 'ON' if onoffs[i] else 'OFF')
                pass
            pass
        self.log.info(msg)
        return onoffs, msg

    def check_stopper(self, session, params=None):
        if params is None: params = {}
        io_name = params.get('io_name')
        onoffs = []
        msg = ''
        with self.lock.acquire_timeout(timeout=3, job='check_stopper') as acquired:
            if not acquired:
                self.log.warn('Lock could not be acquired because it is held by {}.'.format(self.lock.job))
                return False, 'Could not acquire lock in check_stopper().'
            if self.controlling :
                self.log.warn('Actuator is controlled by another function.')
                return False, 'Actuator control is held by another function.'
            self.controlling = True
            onoffs   = self.stopper.get_onoff(io_name)
            self.controlling = False
            io_names = self.stopper.get_io_name(io_name)
            pinlabels= self.stopper.get_label(io_name)
            for i, io_name in enumerate(io_names) :
                pinlabel = pinlabels[i]
                msg += '{:10s} ({:20s}) : {}\n'.format(io_name, pinlabel, 'ON' if onoffs[i] else 'OFF')
                pass
            pass
        self.log.info(msg)
        return onoffs, msg

    def insert(self, session, params=None):
        with self.lock.acquire_timeout(timeout=3, job='insert') as acquired:
            if not acquired:
                self.log.warn('Lock could not be acquired because it is held by {}.'.format(self.lock.job))
                return False, 'Could not acquire lock in insert().'

            if self.controlling :
                self.log.warn('Actuator is controlled by another function.')
                return False, 'Actuator control is held by another function.'
         
            # Running
            self.controlling = True
            time.sleep(1)
         
            # Moving commands
            ret = self._insert(850, 1.0)
            if not ret :
                self.log.error('Failed to insert!')
                return False, 'Failed insert() in _insert(850,1.0)'
         
            # Finishing
            self.controlling = False
            pass

        return True, 'Finish insert()'


    def eject(self, session, params=None):
        with self.lock.acquire_timeout(timeout=3, job='eject') as acquired:
            if not acquired:
                self.log.warn('Lock could not be acquired because it is held by {}.'.format(self.lock.job))
                return False, 'Could not acquire lock in eject().'

            if self.controlling :
                self.log.warn('Actuator is controlled by another function.')
                return False, 'Actuator control is held by another function.'
         
            # Running
            self.controlling = True
            time.sleep(1)
         
            # Moving commands
            ret = self._eject(850, 1.0)
            if not ret :
                self.log.error('Failed to insert!')
                return False, 'Failed eject() in _eject(850,1.0)'
         
            # Finishing
            self.controlling = False
            pass

        return True, 'Finish eject()'


    def insert_homing(self, session, params=None):
        with self.lock.acquire_timeout(timeout=3, job='insert_homing') as acquired:
            if not acquired:
                self.log.warn('Lock could not be acquired because it is held by {}.'.format(self.lock.job))
                return False, 'Could not acquire lock in insert_homing().'

            if self.controlling :
                self.log.warn('Actuator is controlled by another function.')
                return False, 'Actuator control is held by another function.'
         
            # Running
            self.controlling = True
            time.sleep(1)
         
            # Moving commands
            ret = self._insert(1000, 0.1)
            if not ret :
                self.log.error('Failed to insert_homing!')
                return False, 'Failed insert_homing() in _insert(1000,0.1)'
         
            # Finishing
            self.controlling = False
            pass

        return True, 'Finish insert_homing()'


    def eject_homing(self, session, params=None):
        with self.lock.acquire_timeout(timeout=3, job='eject_homing') as acquired:
            if not acquired:
                self.log.warn('Lock could not be acquired because it is held by {}.'.format(self.lock.job))
                return False, 'Could not acquire lock in eject_homing().'

            if self.controlling :
                self.log.warn('Actuator is controlled by another function.')
                return False, 'Actuator control is held by another function.'
         
            # Running
            self.controlling = True
            time.sleep(1)
         
            # Moving commands
            ret = self._eject(1000, 0.1)
            if not ret :
                self.log.error('Failed to eject_homing!')
                return False, 'Failed eject_homing() in _eject(1000,0.1)'
         
            # Finishing
            self.controlling = False
            pass

        return True, 'Finish eject_homing()'


    def stop(self, session, params=None):
        self.log.warn('Try to stop and hold the actuator.')
        if self.controlling :
            self.log.warn('Actuator is controlled by another function.')
            pass
        
        self.controlling = True
        # This will disable move() command in Actuator class until release() is called.
        self.actuator.STOP = True 
        # Hold the actuator
        ret, msg = self.actuator.hold()
        if not ret : return False, msg
        self.controlling = False

        return True, 'Finish stop()'


    def start_acq(self, session, params=None):
        if params is None: params = {}

        # Define data taking interval_time 
        interval_time = params.get('interval-time', None)
        # If interval-time is None, use value passed to Agent init
        if interval_time is None :
            self.log.info('Not set by parameter of "interval-time" for start_acq()')
            interval_time = self.interval_time
        else :
            try:
                interval_time = float(interval_time)
            except ValueError as error:
                self.log.warn('Parameter of "interval-time" is incorrect : {}'.format(error))
                interval_time = self.interval_time
                pass
        self.log.info('interval time for acquisition of limitswitch&stopper = {} sec'.format(interval_time))

        with self.lock.acquire_timeout(timeout=0, job='acq') as acquired:
            if not acquired:
                self.log.warn('Lock could not be acquired because it is held by {}.'.format(self.lock.job))
                return False, 'Could not acquire lock in start_acq().'

        session.set_status('running')

        self.run_acq = True
        session.data = {'fields':{}}
        while self.run_acq:
            current_time = time.time()
            data = {'timestamp': current_time, 'block_name': 'actuator_onoff', 'data': {}}

            # Take data
            onoff_dict_ls = {}
            onoff_dict_st = {}
            if not self.controlling:
                # Get onoff
                onoff_ls = self.limitswitch.get_onoff()
                onoff_st = self.stopper.get_onoff()
                # Data for limitswitch
                for onoff, name in zip(onoff_ls, self.limitswitch.io_names) : 
                    data['data']['limitswitch_{}'.format(name)] = onoff
                    onoff_dict_ls[name] = onoff
                    pass
                # Data for stopper
                for onoff, name in zip(onoff_st, self.stopper.io_names) : 
                    data['data']['stopper_{}'.format(name)] = onoff
                    onoff_dict_st[name] = onoff
                    pass
            else:
                time.sleep(2.+interval_time) # wait for at least 2 sec
                continue
                pass
            # publish data
            self.agent.publish_to_feed('WGActuator', data)
            # store session.data
            field_dict = {'limitswitch': onoff_dict_ls, 'stopper': onoff_dict_st}
            session.data['timestamp']=current_time
            session.data['fields']=field_dict
            #print('data = {}'.format(field_dict))

            # wait an interval
            time.sleep(interval_time)
            pass

        self.agent.feeds['WGActuator'].flush_buffer()
        return True, 'Acquisition exited cleanly'

    def stop_acq(self, session, params=None):
        if self.run_acq : 
            self.run_acq = False
            session.set_status('stopping')
            return True, 'Stop data acquisition'
        session.set_status('??????')
        return False, 'acq is not currently running'


    # End of class WiregridActuatorAgent


def make_parser(parser = None):
    if parser is None:
        parser = argparse.ArgumentParser()

    pgroup = parser.add_argument_group('Agent Options')
    pgroup.add_argument('--interval-time', dest='interval_time', type=float, default=1,
                        help='Interval time for data taking')
    pgroup.add_argument('--ip-address', dest='ip_address', type=str, default='192.168.1.100',
                        help='IP address of the actuator controller')
    pgroup.add_argument('--sleep', dest='sleep', type=float, default=0.10,
                        help='Sleep time for every actuator command')
    pgroup.add_argument('--verbose', dest='verbose', type=int, default=0,
                        help='Verbosity level')
    return parser

if __name__ == '__main__':
    site_parser = site_config.add_arguments()
    if parser is None: parser = argparse.ArgumentParser()
    parser = make_parser(site_parser)

    args = parser.parse_args()

    site_config.reparse_args(args, 'WiregridActuatorAgent')
    agent, runner = ocs_agent.init_site_agent(args)
    interval_time = args.interval_time
    ip_address = args.ip_address
    sleep = args.sleep
    actuator_agent = WiregridActuatorAgent(agent, ip_address, interval_time, sleep=sleep, verbose=args.verbose)

    agent.register_task('check_limitswitch', actuator_agent.check_limitswitch)
    agent.register_task('check_stopper', actuator_agent.check_stopper)
    agent.register_task('insert', actuator_agent.insert)
    agent.register_task('eject', actuator_agent.eject)
    agent.register_task('insert_homing', actuator_agent.insert_homing)
    agent.register_task('eject_homing', actuator_agent.eject_homing)
    agent.register_task('stop', actuator_agent.stop)
    agent.register_process('acq', actuator_agent.start_acq, actuator_agent.stop_acq,startup=True)

    runner.run(agent, auto_reconnect=True)

